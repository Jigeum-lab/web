/**
 * Generated by orval v7.1.1 üç∫
 * Do not edit manually.
 * PhaseOn API
 * ÌéòÏù¥Ï¶àÏò® API Î¨∏ÏÑú
 * OpenAPI spec version: v1
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import type {
  ApiResponseBoolean,
  ApiResponseObject,
  ApiResponseProject,
  CheckSlugAvailabilityParams,
  ProjectMetadataRequest
} from '../../types/apis'
import { customInstance } from '../../api/custom-instance';
import type { ErrorType, BodyType } from '../../api/custom-instance';



/**
 * ## ÌîÑÎ°úÏ†ùÌä∏ ÏÉùÏÑ± API ÏûÖÎãàÎã§.
 * @summary ÌîÑÎ°úÏ†ùÌä∏ ÏÉùÏÑ±
 */
export const createProject = (
    projectMetadataRequest: BodyType<ProjectMetadataRequest>,
 ) => {
      
      const formData = new FormData();
formData.append('title', projectMetadataRequest.title)
if(projectMetadataRequest.slug !== undefined) {
 formData.append('slug', projectMetadataRequest.slug)
 }
formData.append('subTitle', projectMetadataRequest.subTitle)
formData.append('summary', projectMetadataRequest.summary)
if(projectMetadataRequest.thumbnail !== undefined) {
 formData.append('thumbnail', projectMetadataRequest.thumbnail)
 }
if(projectMetadataRequest.banner !== undefined) {
 formData.append('banner', projectMetadataRequest.banner)
 }
formData.append('brandColor', projectMetadataRequest.brandColor)
projectMetadataRequest.categories.forEach(value => formData.append('categories', value));
formData.append('phase', projectMetadataRequest.phase.toString())

      return customInstance<ApiResponseProject>(
      {url: `/api/v1/projects`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData
    },
      );
    }
  


export const getCreateProjectMutationOptions = <TError = ErrorType<ApiResponseObject>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProject>>, TError,{data: BodyType<ProjectMetadataRequest>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createProject>>, TError,{data: BodyType<ProjectMetadataRequest>}, TContext> => {
const {mutation: mutationOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createProject>>, {data: BodyType<ProjectMetadataRequest>}> = (props) => {
          const {data} = props ?? {};

          return  createProject(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateProjectMutationResult = NonNullable<Awaited<ReturnType<typeof createProject>>>
    export type CreateProjectMutationBody = BodyType<ProjectMetadataRequest>
    export type CreateProjectMutationError = ErrorType<ApiResponseObject>

    /**
 * @summary ÌîÑÎ°úÏ†ùÌä∏ ÏÉùÏÑ±
 */
export const useCreateProject = <TError = ErrorType<ApiResponseObject>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProject>>, TError,{data: BodyType<ProjectMetadataRequest>}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createProject>>,
        TError,
        {data: BodyType<ProjectMetadataRequest>},
        TContext
      > => {

      const mutationOptions = getCreateProjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Ïä¨Îü¨Í∑∏ Ï§ëÎ≥µ ÌôïÏù∏ API ÏûÖÎãàÎã§.<br>
### ÏÇ¨Ïö© Î∂àÍ∞ÄÎä• slug (ÏòàÏïΩÏñ¥)
- `slug`
### Return ÏÑ§Î™Ö
- `true` : ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïä¨Îü¨Í∑∏
- `false` : ÏÇ¨Ïö© Î∂àÍ∞ÄÎä•Ìïú Ïä¨Îü¨Í∑∏
    
 * @summary Ïä¨Îü¨Í∑∏ Ï§ëÎ≥µ ÌôïÏù∏
 */
export const checkSlugAvailability = (
    params: CheckSlugAvailabilityParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ApiResponseBoolean>(
      {url: `/api/v1/slug-check`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getCheckSlugAvailabilityQueryKey = (params: CheckSlugAvailabilityParams,) => {
    return [`/api/v1/slug-check`, ...(params ? [params]: [])] as const;
    }

    
export const getCheckSlugAvailabilityInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof checkSlugAvailability>>>, TError = ErrorType<ApiResponseObject>>(params: CheckSlugAvailabilityParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkSlugAvailability>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckSlugAvailabilityQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkSlugAvailability>>> = ({ signal }) => checkSlugAvailability(params, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkSlugAvailability>>, TError, TData> & { queryKey: QueryKey }
}

export type CheckSlugAvailabilityInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof checkSlugAvailability>>>
export type CheckSlugAvailabilityInfiniteQueryError = ErrorType<ApiResponseObject>


export function useCheckSlugAvailabilityInfinite<TData = InfiniteData<Awaited<ReturnType<typeof checkSlugAvailability>>>, TError = ErrorType<ApiResponseObject>>(
 params: CheckSlugAvailabilityParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkSlugAvailability>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkSlugAvailability>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useCheckSlugAvailabilityInfinite<TData = InfiniteData<Awaited<ReturnType<typeof checkSlugAvailability>>>, TError = ErrorType<ApiResponseObject>>(
 params: CheckSlugAvailabilityParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkSlugAvailability>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkSlugAvailability>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useCheckSlugAvailabilityInfinite<TData = InfiniteData<Awaited<ReturnType<typeof checkSlugAvailability>>>, TError = ErrorType<ApiResponseObject>>(
 params: CheckSlugAvailabilityParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkSlugAvailability>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
/**
 * @summary Ïä¨Îü¨Í∑∏ Ï§ëÎ≥µ ÌôïÏù∏
 */

export function useCheckSlugAvailabilityInfinite<TData = InfiniteData<Awaited<ReturnType<typeof checkSlugAvailability>>>, TError = ErrorType<ApiResponseObject>>(
 params: CheckSlugAvailabilityParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkSlugAvailability>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCheckSlugAvailabilityInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCheckSlugAvailabilityQueryOptions = <TData = Awaited<ReturnType<typeof checkSlugAvailability>>, TError = ErrorType<ApiResponseObject>>(params: CheckSlugAvailabilityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkSlugAvailability>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckSlugAvailabilityQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkSlugAvailability>>> = ({ signal }) => checkSlugAvailability(params, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkSlugAvailability>>, TError, TData> & { queryKey: QueryKey }
}

export type CheckSlugAvailabilityQueryResult = NonNullable<Awaited<ReturnType<typeof checkSlugAvailability>>>
export type CheckSlugAvailabilityQueryError = ErrorType<ApiResponseObject>


export function useCheckSlugAvailability<TData = Awaited<ReturnType<typeof checkSlugAvailability>>, TError = ErrorType<ApiResponseObject>>(
 params: CheckSlugAvailabilityParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkSlugAvailability>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkSlugAvailability>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useCheckSlugAvailability<TData = Awaited<ReturnType<typeof checkSlugAvailability>>, TError = ErrorType<ApiResponseObject>>(
 params: CheckSlugAvailabilityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkSlugAvailability>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkSlugAvailability>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useCheckSlugAvailability<TData = Awaited<ReturnType<typeof checkSlugAvailability>>, TError = ErrorType<ApiResponseObject>>(
 params: CheckSlugAvailabilityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkSlugAvailability>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
/**
 * @summary Ïä¨Îü¨Í∑∏ Ï§ëÎ≥µ ÌôïÏù∏
 */

export function useCheckSlugAvailability<TData = Awaited<ReturnType<typeof checkSlugAvailability>>, TError = ErrorType<ApiResponseObject>>(
 params: CheckSlugAvailabilityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkSlugAvailability>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCheckSlugAvailabilityQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



